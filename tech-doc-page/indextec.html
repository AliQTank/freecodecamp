<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Unix Shell</title>
    <link rel="stylesheet" href="styletech.css">
</head>
<body>
    <nav id="navbar"> <!-- requirement #8-->
       
        <ul> <header>The Unix Shell </header> <!--requirement #10 one a element for every main-section element -->
            <li><a class="nav-link" href="#Introduction">Introduction</a><!--requirement #12 --></li>
            <li><a class="nav-link" href="#Navigating_Files_and_Directories">Navigating Files and Directories</a><!--requirement #12 --></li>
            <li><a class="nav-link" href="#Working_With_Files_and_Directories">Working With Files and Directories</a><!--requirement #12 --></li>
            <li><a class="nav-link" href="#Pipes_and_Filters">Pipes and Filters</a><!--requirement #12 --></li>
            <li><a class="nav-link" href="#Loops">Loops</a><!--requirement #12 --></li>
            <li><a class="nav-link" href="#Shell_Scripts">Shell Scripts</a></li>
            <li><a class="nav-link" href="#Finding_Things">Finding Things</a></li>
        </ul>
    </nav>
    <main id="main-doc"> <!-- requirement #1 -->
        <header> <h1>Shell Documentation</h1> </header>
    <section id="Introduction" class="main-section"> <!-- requirements #2 --> <!-- requirements #4 --> 
        
        <header><h1>Introduction</h1> </header> <!--requirements #3 -->
        <p>Shell is defined as a CLI (Command Line Interface) where Users can type commands.</p> <!--requirements #5 -->
        <code class="input">$ ls</code>    
        <p>This command will list the contents of the current directory:</p>
        <code class="output">output:</code>
    </section> 
    <section id="Navigating_Files_and_Directories" class="main-section"> <!-- requirements #2 --> <!-- requirements #4 --> 
        <header><h1>Navigating Files and Directories</h1></header> <!--requirements #3 -->
        <h3>Exploring Other Directories</h3>
        <code class="input">ls -F</code>
        <p>to take a look at others Directories</p>
        <code class="input">ls -F Desktop/shell-lesson-data</code> <br>
        <code class="output">output exercise-data/  north-pacific-gyre/</code>
        <p>to change directory there is a command very similar to ls</p>
        <code class="input">cd Desktop</code> <br>
        <code class="input">cd shell-lesson-data</code> <br>
        <code class="input">cd exercise-data</code>
        <p>we are now in /Users/nelle/Desktop/shell-lesson-data/exercise-data</p>
        <code class="input">$ pwd</code> <br>
        <code class="output">/Users/nelle/Desktop/shell-lesson-data/exercise-data</code>
        <p>to move one directory up</p>
        <code class="input">$ cd ..</code>
        <p>to move two directories up</p>
        <code class="input">$ cd ../..</code>
        <p>to get back to root directory</p>
        <code class="input">$ cd</code>
    </section>
    <section id="Working_With_Files_and_Directories" class="main-section"> <!-- requirements #2 --> <!-- requirements #4 --> 
        <header><h1>Working With Files and Directories</h1></header> <!--requirements #3 -->
        <h3>Create a directory</h3>
        <p>Let’s create a new directory called thesis using the command mkdir thesis (which has no output):</p>
        <code class="input">$ mkdir thesis</code>
        <p>to create a directory nested into direct parent folder</p>
        <code class="input">$ mkdir -p ../project/data ../project/results</code>
        <p>the <code>-R</code>option to the <code>ls</code> command will list all nested subdirectories within a directory. Let’s use ls -FR to recursively list the new directory hierarchy we just created in the project directory:</p>
        <code class="input">$ ls -FR ../project</code> <br>
        <code class="output">../project/:
            data/  results/
            
            ../project/data:
            
            ../project/results:</code>
            <h3>Create a text file</h3>
            <p>Let’s change our working directory to thesis using cd, then run a text editor called Nano to create a file called draft.txt:</p>
            <code class="input">$ cd thesis </code> <br>
               <code class="input">$ nano draft.txt</code>
                <p>When we say, ‘nano is a text editor’ we really do mean ‘text’: it can only work with plain character data, not tables, 
                    images, or any other human-friendly media. </p>
                    <p>Let’s type in a few lines of text. Once we’re happy with our text, 
                        we can press Ctrl+O (press the Ctrl or Control key and, while holding it down, press the O key) to write our data to disk 
                        (we’ll be asked what file we want to save this to: press Return to accept the suggested default of draft.txt).</p>
                        <img src="https://swcarpentry.github.io/shell-novice/fig/nano-screenshot.png" alt="nano photo">
                        <p>Once our file is saved, we can use Ctrl+X to quit the editor and return to the shell.</p>
                        <code class="input">$ ls</code> <br>
                        <code class="output">draft.txt</code>
                        <p>We have seen how to create text files using the nano editor. Now, try the following command:</p>
                        <code class="input">$ touch my_file.txt</code>
                        <ul>
                            <li>The touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.</li>
                            <li>When you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.</li>
                            <li>Some programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.</li>
                            
                        </ul>
                        <h3>Moving files and directories</h3>
                        <p>Returning to the shell-lesson-data/exercise-data/writing directory,</p>
                        <code class="input">$ cd ~/Desktop/shell-lesson-data/exercise-data/writing</code>
                        <p>In our thesis directory we have a file draft.txt which isn’t a particularly informative name, so let’s change the file’s name using mv, 
                            which is short for ‘move’:</p>
                            <code class="input">$ mv thesis/draft.txt thesis/quotes.txt</code>    
                            <p>The first argument tells mv what we’re ‘moving’, while the second is where it’s to go. In this case, 
                                we’re moving thesis/draft.txt to thesis/quotes.txt, which has the same effect as renaming the file. Sure enough, 
                                ls shows us that thesis now contains one file called quotes.txt:</p>
                                <code class="input">$ ls thesis</code> <br>
                                <code class="output">quotes.txt</code>   
                                <p>One must be careful when specifying the target file name, since mv will silently overwrite any existing file with the same name,
                                    which could lead to data loss. An additional option, mv -i (or mv --interactive), can be used to make mv ask you for confirmation
                                    before overwriting.</p> 
                                    <p>Note that mv also works on directories.</p>
                                    <p>Let’s move quotes.txt into the current working directory. We use mv once again, but this time we’ll use just the name of a directory
                                        as the second argument to tell mv that we want to keep the filename but put the file somewhere new. (This is why the command
                                        is called ‘move’.) In this case, the directory name we use is the special directory name . that we mentioned earlier.</p>
                                        <code class="input">$ mv thesis/quotes.txt .</code>      
                                        <p>The effect is to move the file from the directory it was in to the current working directory. ls now shows us that thesis is empty:</p>
                                        <code class="input">$ ls thesis</code> <br>
                                        <code class="output">$</code>
                                        <p>Alternatively, we can confirm the file quotes.txt is no longer present in the thesis directory by explicitly trying to list it:</p>
                                        <h3>Copying files and directories</h3>
                                        <p>The cp command works very much like mv, except it copies a file instead of moving it. We can check that it did the right thing
                                            using ls with two paths as arguments — like most Unix commands, ls can be given multiple paths at once:</p>
                                            <code class="input">$ cp quotes.txt thesis/quotations.txt
                                                $ ls quotes.txt thesis/quotations.txt</code> <br>
                                                <code class="output"> quotes.txt   thesis/quotations.txt</code> 
                                                <p>We can also copy a directory and all its contents by using the recursive option -r, e.g. to back up a directory:</p>
                                                <code class="input">$ cp -r thesis thesis_backup</code>
                                                <p>We can check the result by listing the contents of both the thesis and thesis_backup directory:</p>
                                                <code class="input">$ ls thesis thesis_backup</code> <br>
                                                <code class="output">thesis:
                                                    quotations.txt
                                                    
                                                    thesis_backup:
                                                    quotations.txt</code>
                                                    
                                                </section>

                

    <section id="Pipes_and_Filters" class="main-section"> <!-- requirements #2 --> <!-- requirements #4 --> 
        <header><h1>Pipes and Filters</h1></header> <!--requirements #3 -->
        <p>Now that we know a few basic commands, we can finally look at the shell’s most powerful feature: the ease with which it lets us combine
             existing programs in new ways. We’ll start with the directory shell-lesson-data/exercise-data/proteins that contains six files describing
              some simple organic molecules. The .pdb extension indicates that these files are in Protein Data Bank format, a simple text format that 
              specifies the type and position of each atom in the molecule.</p>
        <code class="input">$ ls proteins</code> <br>
        <code class="output">cubane.pdb    methane.pdb    pentane.pdb
            ethane.pdb    octane.pdb     propane.pdb</code>
            <p>Let’s go into that directory with cd and run an example command wc cubane.pdb:</p>
            <code class="input">$ cd proteins <br>
                $ wc cubane.pdb</code> <br>
            <code class="output">20  156 1158 cubane.pdb</code>  
            <p>wc is the ‘word count’ command: it counts the number of lines, words, and characters in files (from left to right, in that order).</p> 
            <p>If we run the command wc *.pdb, the * in *.pdb matches zero or more characters, so the shell turns *.pdb into a list of all .pdb files
                 in the current directory:</p>
            <code class="input">$ wc *.pdb</code>   <br>
            <code class="output">  20  156  1158  cubane.pdb
                12  84   622   ethane.pdb
                 9  57   422   methane.pdb
                30  246  1828  octane.pdb
                21  165  1226  pentane.pdb
                15  111  825   propane.pdb
               107  819  6081  total</code>  
            <p>Note that wc *.pdb also shows the total number of all lines in the last line of the output.</p>
            <p>If we run wc -l instead of just wc, the output shows only the number of lines per file:</p>
            <code class="input">$ wc -l *.pdb</code> <br>
            <code class="output">  20  cubane.pdb
                12  ethane.pdb
                 9  methane.pdb
                30  octane.pdb
                21  pentane.pdb
                15  propane.pdb
               107  total</code>
            <p>The -m and -w options can also be used with the wc command, to show only the number of characters or the number of words in the files.</p>
            <h3>Capturing output from commands</h3>
            <p>Which of these files contains the fewest lines? It’s an easy question to answer when there are only six files, but what if there 
                were 6000? Our first step toward a solution is to run the command:</p>   
            <code class="input">$ wc -l *.pdb > lengths.txt</code>
            <p>The greater than symbol, >, tells the shell to redirect the command’s output to a file instead of printing it to the screen. 
                (This is why there is no screen output: everything that wc would have printed has gone into the file lengths.txt instead.) 
                The shell will create the file if it doesn’t exist. If the file exists, it will be silently overwritten, 
                which may lead to data loss and thus requires some caution. ls lengths.txt confirms that the file exists:</p>
                <code class="input">$ ls lengths.txt</code> <br>
                <code class="output">lengths.txt</code>
                <p>We can now send the content of lengths.txt to the screen using cat lengths.txt. The cat command gets its name from ‘concatenate’ i.e. join together,
                     and it prints the contents of files one after another. There’s only one file in this case, so cat just shows us what it contains:</p>
                <code class="input">$ cat lengths.txt</code> <br>
                <code class="output">  20  cubane.pdb
                    12  ethane.pdb
                     9  methane.pdb
                    30  octane.pdb
                    21  pentane.pdb
                    15  propane.pdb
                   107  total</code>
                <h3>Filtering output</h3>
                <p>Next we’ll use the sort command to sort the contents of the lengths.txt file. But first we’ll use an exercise to learn a little about
                     the sort command:</p>
                 <p>The file shell-lesson-data/exercise-data/numbers.txt contains the following lines:</p>    
                 <code class="output">10
                    2
                    19
                    22
                    6</code> <br>
                  <code class="input">$ sort numbers.txt</code> <br>
                  <code class="output">10
                    19
                    2
                    22
                    6</code>  <br>
                   <code class="input">$ sort -n numbers.txt</code> <br>
                   <code class="output">2
                    6
                    10
                    19
                    22</code> 

    </section>
    <section id="Loops" class="main-section"> <!-- requirements #2 --> <!-- requirements #4 --> 
        <header><h1>Loops</h1> </header> <!--requirements #3 -->

        <p>Loops are a programming construct which allow us to repeat a command or set of commands for each item in a list.
             As such they are key to productivity improvements through automation. Similar to wildcards and tab completion,
             using loops also reduces the amount of typing required (and hence reduces the number of typing mistakes).</p>
        <p>Suppose we have several hundred genome data files named basilisk.dat, minotaur.dat, and unicorn.dat. For this example, 
            we’ll use the exercise-data/creatures directory which only has three example files, 
            but the principles can be applied to many many more files at once.</p>
        <p>The structure of these files is the same: the common name, classification, 
            and updated date are presented on the first three lines, with DNA sequences on the following lines. Let’s look at the files:</p>
            <code class="input">$ head -n 5 basilisk.dat minotaur.dat unicorn.dat</code>
        <p>We would like to print out the classification for each species, which is given on the second line of each file. 
            For each file, we would need to execute the command head -n 2 and pipe this to tail -n 1. We’ll use a loop to solve this problem:</p>  
            <code class="input">$ for filename in basilisk.dat minotaur.dat unicorn.dat
                > do
                >     head -n 2 $filename | tail -n 1
                > done</code>  <br>
            <code class="output">CLASSIFICATION: basiliscus vulgaris 
                CLASSIFICATION: bos hominus 
                CLASSIFICATION: equus monoceros</code> 
        <p>The shell prompt changes from $ to > and back again as we were typing in our loop. The second prompt, >, is different to remind us
             that we haven’t finished typing a complete command yet. A semicolon, ;, can be used to separate two commands written on a single line.</p>  
        <p>When the shell sees the keyword for, it knows to repeat a command (or group of commands) once for each item in a list. 
            Each time the loop runs (called an iteration), an item in the list is assigned in sequence to the variable,
             and the commands inside the loop are executed, before moving on to the next item in the list. 
             Inside the loop, we call for the variable’s value by putting $ in front of it. The $ tells the shell interpreter
              to treat the variable as a variable name and substitute its value in its place, rather than treat it as text or an external command.</p>  
        <p>In this example, the list is three filenames: basilisk.dat, minotaur.dat, and unicorn.dat. Each time the loop iterates, 
            it will assign a file name to the variable filename and run the head command. The first time through the loop, $filename is basilisk.dat. 
            The interpreter runs the command head on basilisk.dat and pipes the first two lines to the tail command, 
            which then prints the second line of basilisk.dat. For the second iteration, $filename becomes minotaur.dat. This time, 
            the shell runs head on minotaur.dat and pipes the first two lines to the tail command, which then prints the second line of minotaur.dat.
             For the third iteration, $filename becomes unicorn.dat, so the shell runs the head command on that file, and tail on the output of that.
              Since the list was only three items, the shell exits the for loop.</p>               
    </section>
    <section id="Shell_Scripts" class="main-section">
        <header><h1>Shell Scripts</h1> </header>
        <p>We are finally ready to see what makes the shell such a powerful programming environment. We are going to take the commands we 
            repeat frequently and save them in files so that we can re-run all those operations again later by typing a single command. 
            For historical reasons, a bunch of commands saved in a file is usually called a shell script, 
            but make no mistake: these are actually small programs.</p>
        <p>Not only will writing shell scripts make your work faster — you won’t have to retype the same commands over and over again 
            — it will also make it more accurate (fewer chances for typos) and more reproducible. If you come back to your work later
             (or if someone else finds your work and wants to build on it) you will be able to reproduce the same results simply 
             by running your script, rather than having to remember or retype a long list of commands.</p>    
        <p>Let’s start by going back to proteins/ and creating a new file, middle.sh which will become our shell script:</p>
        <code class="input">$ cd proteins
            $ nano middle.sh</code>
        <p>The command nano middle.sh opens the file middle.sh within the text editor ‘nano’ (which runs within the shell). 
            If the file does not exist, it will be created. We can use the text editor to directly edit the file – we’ll simply 
            insert the following line:</p>            
        <code class="input bash">head -n 15 octane.pdb | tail -n 5</code>
        <p>This is a variation on the pipe we constructed earlier: it selects lines 11-15 of the file octane.pdb. 
            Remember, we are not running it as a command just yet: we are putting the commands in a file.</p>
        <p>Then we save the file (Ctrl-O in nano), and exit the text editor (Ctrl-X in nano). 
            Check that the directory proteins now contains a file called middle.sh.</p>    
        <p>Once we have saved the file, we can ask the shell to execute the commands it contains. Our shell is called bash, 
            so we run the following command:</p>    
        <code class="input">$ bash middle.sh</code>   <br>
        <code class="output">
            ATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00
ATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00
ATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00
ATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00
ATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00

        </code> 
        <p>What if we want to select lines from an arbitrary file? We could edit middle.sh each time to change the filename, 
            but that would probably take longer than typing the command out again in the shell and executing it with a new file name. 
            Instead, let’s edit middle.sh and make it more versatile:</p>
        <code>$ nano middle.sh</code> <br>
        <code class="input bash">head -n 15 "$1" | tail -n 5</code>
        <p>Inside a shell script, $1 means ‘the first filename (or other argument) on the command line’. We can now run our script like this:</p>
        <code class="input">$ bash middle.sh octane.pdb</code> <br>
        <code class="output">ATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00
            ATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00
            ATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00
            ATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00
            ATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00</code>
            <hr>
            <ul>Key points
                <li>Save commands in files (usually called shell scripts) for re-use.</li>
                <li>bash [filename] runs the commands saved in a file.</li>
                <li>$@ refers to all of a shell script’s command-line arguments.</li>
                <li>$1, $2, etc., refer to the first command-line argument, the second command-line argument, etc.</li>
                <li>Place variables in quotes if the values might have spaces in them.</li>
                <li>Letting users decide what files to process is more flexible and more consistent with built-in Unix commands.</li>
            </ul>


    </section>
    <section id="Finding_Things" class="main-section">
        <header><h1>Finding Things</h1></header>
        <p>In the same way that many of us now use ‘Google’ as a verb meaning ‘to find’, Unix programmers often use the word ‘grep’. 
            ‘grep’ is a contraction of ‘global/regular expression/print’, a common sequence of operations in early Unix text editors. 
            It is also the name of a very useful command-line program.</p>
        <p>grep finds and prints lines in files that match a pattern. For our examples, we will use a file that contains three haiku 
            taken from a 1998 competition in Salon magazine. For this set of examples, we’re going to be working in the writing subdirectory:</p>
        <code class="input">$ cd
            $ cd Desktop/shell-lesson-data/exercise-data/writing
            $ cat haiku.txt</code> 
         <code class="output">The Tao that is seen
            Is not the true Tao, until
            You bring fresh toner.
            
            With searching comes loss
            and the presence of absence:
            "My Thesis" not found.
            
            Yesterday it worked
            Today it is not working
            Software is like that.</code>   
        <p>Let’s find lines that contain the word ‘not’:</p>
        <code class="input">$ grep not haiku.txt</code> <br>
        <code class="output">Is not the true Tao, until
            "My Thesis" not found
            Today it is not working</code>
        <p>Let’s search for the pattern: ‘The’.</p>    
        <code class="input">$ grep The haiku.txt</code> <br>
        <code class="output">The Tao that is seen
            "My Thesis" not found.</code>
        <p>This time, two lines that include the letters ‘The’ are outputted, one of which contained our search pattern within a larger word, 
            ‘Thesis’.</p>
        <p>To restrict matches to lines containing the word ‘The’ on its own, we can give grep with the -w option. 
            This will limit matches to word boundaries.</p>   
        <code class="input">$ grep -w The haiku.txt</code>  <br>
        <code class="output">The Tao that is seen</code>
        <p>Note that a ‘word boundary’ includes the start and end of a line, so not just letters surrounded by spaces. 
            Sometimes we don’t want to search for a single word, but a phrase. This is also easy to do with grep by putting the phrase in quotes.</p>
        <code class="input">$ grep -w "is not" haiku.txt</code><br>
        <code class="output">Today it is not working</code>
        <p>Another useful option is -n, which numbers the lines that match:</p>
        <code class="input">$ grep -n "it" haiku.txt</code><br>
        <code class="output">5:With searching comes loss
            9:Yesterday it worked
            10:Today it is not working</code>
        <p>Here, we can see that lines 5, 9, and 10 contain the letters ‘it’.</p>  
        <p>We can combine options (i.e. flags) as we do with other Unix commands. For example, let’s find the lines that contain the word ‘the’. 
            We can combine the option -w to find the lines that contain the word ‘the’ and -n to number the lines that match:</p>  
        <code class="input">$ grep -n -w "the" haiku.txt</code>  <br>
        <code class="output">2:Is not the true Tao, until
            6:and the presence of absence:</code>
        <p>Now we want to use the option -i to make our search case-insensitive:</p>
        <code class="input">$ grep -n -w -i "the" haiku.txt</code><br>
        <code class="output">1:The Tao that is seen
            2:Is not the true Tao, until
            6:and the presence of absence:</code>
        <p>Now, we want to use the option -v to invert our search, i.e., we want to output the lines that do not contain the word ‘the’.</p>
        <code class="input">$ grep -n -w -v "the" haiku.txt</code><br>
        <code class="output">1:The Tao that is seen
            3:You bring fresh toner.
            4:
            5:With searching comes loss
            7:"My Thesis" not found.
            8:
            9:Yesterday it worked
            10:Today it is not working
            11:Software is like that.</code>
        <p>If we use the -r (recursive) option, grep can search for a pattern recursively through a set of files in subdirectories.</p>    
        <p>Let’s search recursively for Yesterday in the shell-lesson-data/exercise-data/writing directory:</p>
        <code class="input">$ grep -r Yesterday .</code><br>
        <code class="output">
            ./LittleWomen.txt:"Yesterday, when Aunt was asleep and I was trying to be as still as a
./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then
./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my
./haiku.txt:Yesterday it worked
        </code>
        <p>grep has lots of other options. To find out what they are, we can type:</p>
        <code class="input">$ grep --help</code>
    </section>   
    </main>
    <script src="apptec.js"></script>    
</body>
</html>